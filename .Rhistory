input$Calculate
life_index$Score <- abs((life_index$Purchasing.Power.Index * as.numeric(input$Money) +  life_index$Safety.Index * as.numeric(input$Safety) +   life_index$Health.Care.Index * as.numeric(input$HealthCare) +
life_index$Traffic.Commute.Time.Index * as.numeric(input$Traffic) +
life_index$Pollution.Index * as.numeric(input$Pollution) +
life_index$Cost.of.Living.Index * as.numeric(input$Cost) + life_index$Climate.Index * as.numeric(input$Climate)))/10
sqldf("SELECT Country,Score FROM life_index ORDER BY Score DESC LIMIT 5")
})
output$Country4 <- renderTable({
input$Calculate
Score()
})
}
shinyApp(ui = ui, server = server)
library(sqldf)
library(shiny)
ui <- fluidPage(
titlePanel("Find the Best Country for You"),
sidebarLayout(
sidebarPanel(
h2("Which country is best for you?"),
p("Choose variables from -5 to 5 according to your priority."),
p("5 - It must be/I want."),
p("-5 - It should not be / I do not want."),
p("0 - It does not matter."),
br(),
selectizeInput(inputId = "Money", label = "Money", choices = -5:5, selected = 0),
selectizeInput(inputId = "Safety", label = "Safety Index", choices = -5:5, selected = 0),
selectizeInput(inputId = "HealthCare", label = "Health Care Index", choices = -5:5, selected = 0),
selectizeInput(inputId = "Traffic", label = "Traffic Commute Time Index", choices = -5:5, selected = 0),
selectizeInput(inputId = "Pollution", label = "Pollution Index", choices = -5:5, selected = 0),
selectizeInput(inputId = "Cost", label = "Cost of living Index", choices = -5:5, selected = 0),
selectizeInput(inputId = "Climate", label = "Climate Index", choices = -5:5, selected = 0),
actionButton(inputId = "Calculate", label = "Calculate")
),
mainPanel(
uiOutput("img"),
br(),
p(h3("Your choices:")),
textOutput("Money_out"),
textOutput("Safety_out"),
textOutput("HealthCare_out"),
textOutput("Traffic_out"),
textOutput("Pollution_out"),
textOutput("Cost_out"),
textOutput("Climate_out"),
br(),
p(h2("The country that you should live in:")),
br(),
tableOutput("Country4"),
br(),
br(),
p(h4(strong("Note about the app:"))),
p(h5("In the shiny app, the formula considers seven factors from our dataset: money, safety, health care, climate, traffic jams, pollution, and the cost of living index. Users can rate these factors on a scale from -5 to 5 according to their preferences. The app displays a table ranking the countries based on these scores, highlighting the top five countries that best match the user's preferences,
so assisting users in identifying the most suitable countries for them."))
)
)
)
server <- function(input, output) {
output$img <- renderUI({
tags$img(src = "https://www.arealme.com/cover-images/top-10-country-to-live-in.png", width = 700, height = 350)
})
output$Money_out <- renderText({
input$Calculate
isolate(paste("Money:", input$Money))
})
output$Safety_out <- renderText({
input$Calculate
isolate(paste("Safety:", input$Safety))
})
output$HealthCare_out <- renderText({
input$Calculate
isolate(paste("Health Care:", input$HealthCare))
})
output$Traffic_out <- renderText({
input$Calculate
isolate(paste("Traffic:", input$Traffic))
})
output$Pollution_out <- renderText({
input$Calculate
isolate(paste("Pollution:", input$Pollution))
})
output$Cost_out <- renderText({
input$Calculate
isolate(paste("Cost:", input$Cost))
})
output$Climate_out <- renderText({
input$Calculate
isolate(paste("Climate:", input$Climate))
})
Score <- reactive({
input$Calculate
life_index$Score <- abs((life_index$Purchasing.Power.Index * as.numeric(input$Money) +  life_index$Safety.Index * as.numeric(input$Safety) +   life_index$Health.Care.Index * as.numeric(input$HealthCare) +
life_index$Traffic.Commute.Time.Index * as.numeric(input$Traffic) +
life_index$Pollution.Index * as.numeric(input$Pollution) +
life_index$Cost.of.Living.Index * as.numeric(input$Cost) + life_index$Climate.Index * as.numeric(input$Climate)))/10
sqldf("SELECT Country,Score FROM life_index ORDER BY Score DESC LIMIT 5")
})
output$Country4 <- renderTable({
input$Calculate
Score()
})
}
shinyApp(ui = ui, server = server)
library(parallel)
detectCores()
cl <- makeCluster(detectCores() - 1)
stopCluster(cl)
set.seed(295)
Sys.time()
system.time(x <- rnorm(12^5))
system.time(x <- rnorm(12^6))
system.time(x <- rnorm(12^7))
start_time <- Sys.time()
result_lapply <- lapply(1:15, function(x) x^2)
end_time <- Sys.time()
duration_lapply <- end_time - start_time
duration_lapply
cl <- makeCluster(detectCores() - 1)
cl <- makeCluster(detectCores() - 1)
start <- Sys.time()
result_parlapply <- parLapply(cl, 1:15, function(x) x^2)
end <- Sys.time()
result_parapply <- end - start
stopCluster()
cl <- makeCluster(detectCores() - 1)
start <- Sys.time()
result_parlapply <- parLapply(cl, 1:15, function(x) x^2)
end <- Sys.time()
result_parapply <- end - start
stopCluster()
stopCluster(cl)
result_parlapply
result_parapply
duration_lapply
duration_parapply <- end - start
duration_parapply
e <- 3
clusterExport(cl, "e")
cl <- makeCluster(detectCores() - 1)
clusterExport(cl, "e")
result_parlapply <- parLapply(cl, 1:15, function(x) x^e)
result_parlapply
stopCluster(cl)
cl <- makeCluster(detectCores() - 1)
start <- Sys.time()
result_parlapply <- parLapply(cl, 1:15, function(x) x^e)
end <- Sys.time()
result_parlapply
stopCluster(cl)
library(doParallel)
install.packages(doParallel)
install.packages("doParallel")
cl <- makeCluster(detectCores() - 2)
cl
registerDoParallel(cl)
library(doParallel)
registerDoParallel(cl)
vector <- foreach(1:5, .combine="c") %dopar% {
i^3
}
vector <- foreach(i=1:5, .combine="c") %dopar% {
i^3
}
vector
vector <- foreach(i=1:5, .combine="rbind") %dopar% {
i^3
}
vector
stopCluster()
stopCluster(cl)
library(forea)
library(foreach)
cl <- makeCluster(10)
cl <- makeCluster(10)
v <- foreach(g=1:10, .combine = "c") %dopar% {
g^2
}
registerDoParallel(cl)
v <- foreach(g=1:10, .combine = "c") %dopar% {
g^2
}
mat <- foreach(g=1:10, .combine = "rbind") %dopar% {
g^2
}
l <- foreach(g=1:10, .combine = "list") %dopar% {
g^2
}
stopCluster(cl)
v <- foreach(g=1:10, .combine = "c") %dopar% {
g^2
}
registerDoParallel(cl)
v <- foreach(g=1:10, .combine = "c") %dopar% {
g^2
}
stopCluster(cl)
list(c = v, rbind = mat, list = l)
stopCluster(cl)
diabetes
diabetes <- read_csv("https://raw.githubusercontent.com/mtalibfarooq/Machine_Learning_Diabetes_Dataset/main/diabetes.csv")
library(readr)
diabetes <- read_csv("https://raw.githubusercontent.com/mtalibfarooq/Machine_Learning_Diabetes_Dataset/main/diabetes.csv")
head(diabetes)
ggplot(diabetes, aes(x = BMI, y = Outcome)) +
geom_jitter(width = 0.5, height = 0.08, alpha = 0.6)
library(ggplot2)
ggplot(diabetes, aes(x = BMI, y = Outcome)) +
geom_jitter(width = 0.5, height = 0.08, alpha = 0.6)
ggplot(diabetes, aes(x = BMI, y = Outcome)) +
geom_jitter(width = 0.05, height = 0.8, alpha = 0.6)
ggplot(diabetes, aes(x = BMI, y = Outcome)) +
geom_jitter(width = 0.05, height = 0.08, alpha = 0.6)
ggplot(diabetes, aes(x = BMI, y = Outcome)) +
geom_jitter(width = 0.5, height = 0.08, alpha = 0.6)
ggplot(diabetes, aes(x = BMI, y = Outcome)) +
geom_jitter(width = 0.05, height = 0.08, alpha = 0.6)
ggplot(diabetes, aes(x = BMI, y = Outcome)) +
geom_jitter(width = 0.05, height = 0.04, alpha = 0.6)
ggplot(diabetes, aes(x = BMI, y = Outcome)) +
geom_jitter(width = 0.05, height = 0.04, alpha = 0.6)
library(sloop)
class(Sys.time())
is.object(Sys.time())
otype(Sys.time())
s3_class(Sys.time())
s3_class(Sys.Date())
otype(Sys.Date())
is.object(Sys.Date())
is.object(list())
otype(list())
s3_class(list())
s3_class(c(1, 2, 3))
otype(c(1, 2, 3))
is.object(c(1, 2, 3))
library(shiny)
# Define UI for app that draws a histogram ----
ui <- fluidPage(
# App title ----
titlePanel("Hello Shiny!"),
# Sidebar layout with input and output definitions ----
sidebarLayout(
# Sidebar panel for inputs ----
sidebarPanel(
# Input: Slider for the number of bins ----
sliderInput(inputId = "bins",
label = "Number of bins:",
min = 1,
max = 50,
value = 30)
),
# Main panel for displaying outputs ----
mainPanel(
# Output: Histogram ----
plotOutput(outputId = "distPlot")
)
)
)
# Define server logic required to draw a histogram ----
server <- function(input, output) {
# Histogram of the Old Faithful Geyser Data ----
# with requested number of bins
# This expression that generates a histogram is wrapped in a call
# to renderPlot to indicate that:
#
# 1. It is "reactive" and therefore should be automatically
#    re-executed when inputs (input$bins) change
# 2. Its output type is a plot
output$distPlot <- renderPlot({
x    <- faithful$waiting
bins <- seq(min(x), max(x), length.out = input$bins + 1)
hist(x, breaks = bins, col = "#75AADB", border = "white",
xlab = "Waiting time to next eruption (in mins)",
main = "Histogram of waiting times")
})
}
shinyApp(ui = ui, server = server)
ui <- fluidPage(
titlePanel("title panel"),
sidebarLayout(position = "right",
sidebarPanel("sidebar panel"),
mainPanel("main panel")
)
)
# Define server logic ----
server <- function(input, output) {
}
# Run the app ----
shinyApp(ui = ui, server = server)
ui <- fluidPage(
titlePanel("My Baby Shark App"),
sidebarLayout(
sidebarPanel(),
mainPanel(
img(src = "shark.jpg", height = 140, width = 400)
)
)
)
# Define server logic ----
server <- function(input, output) {
}
# Run the app ----
shinyApp(ui = ui, server = server)
library(sloop)
f <- factor(c("a", "b", "c"))
f
typeof(f)
attributes(f)
unclass(f)
ftype(print)
ftype(str)
ftype(unclass)
print(f)
print(unclass(f))
time <- strptime(c("2017-01-01", "2020-05-04 03:21"), "%Y-%m-%d")
str(time)
str(unclass(time))
s3_dispatch(print(f))
ftype(t.test)
t.test
ftype(t.data.frame)
s3_get_method(t.data.frame)
# Classes
x <- structure(list(), class = "my_class")
x
x <- list()
x
class(x) <- "my_class"
x
inherits(x, "my_class")
inherits(x, "your_class")
mod <- lm(log(mpg) ~ log(disp), data = mtcars)
class(mod)
print(mod)
class(mod) <- "Date"
print(mod)
mod
class(mod)
print(mod)
x <- structure(list(), class="my_class")
new_Date <- function(x = double()){
stopifnot(is.double(x))
structure(x, class="Date")
}
new_Date(c(-1,0,1))
new_difftime <- function(x = double(), units = "secs"){
stopifnot(is.double(x))
units <- match.arg(units, c("secs", "min", "hours", "days", "weeks"))
structure(x,
class = "difftime",
units = units)
}
new_difftime(c(1, 10, 3600), "secs")
new_difftime(52, "weeks")
new_difftime(52, "weekss")
x <- Sys.Date()
x
s3_dispatch(print(x))
s3_methods_generic("mean")
s3_methods_class("ordered")
x <- as.POSIXlt(ISOdatetime(2020, 1, 1, 0, 0, 1:3))
x
length(x)
length(unclass(x))
x[[1]]
unclass(x)[[1]]
x <- data.frame(x=1:100, y=1:100)
x
length(x)
nrow(x)
mod <- lm(mpg ~ wt, data = mtcars)
length(mod)
# Inheritance
class(ordered("x"))
class(Sys.time())
s3_dispatch(print(ordered("x")))
s3_dispatch(print(Sys.time()))
values
x
values <- unclass(x)
values
movie <- read.csv("Databases/blockbuster-top_ten_movies_per_year_DFE.csv")
getwd()
setwd("D:/ODTU/Sem 4/STAT250/STAT250-Final-Project")
movie <- read.csv("Databases/blockbuster-top_ten_movies_per_year_DFE.csv")
library(dplyr)
library(ggplot2)
library(stringr)
head(movie)
str(movie)
# alter worldwide_gross to numeric
movie$worldwide_gross <- as.numeric(gsub("[\\$,]", "", movie$worldwide_gross))
head(movie$worldwide_gross)
nrow(movie)
# group year and get the top 10 movies by worldwide gross for each year
top_10_movies_per_year <- movie %>%
group_by(year) %>%
top_n(10, worldwide_gross)
nrow(top_10_movies_per_year)
# group year and get the top 10 movies by worldwide gross for each year
movie <- movie %>%
group_by(year) %>%
top_n(10, worldwide_gross)
# the average worldwide gross
average_gross_per_year <- movie %>%
group_by(year) %>%
summarise(average_gross = mean(worldwide_gross))
ggplot(average_gross_per_year, aes(x = year, y = average_gross)) +
ggplot(average_gross_per_year, aes(x = year, y = average_gross / 1e6)) +
geom_line(color = "blue", size = 1) +
geom_point(color = "red", size = 2) +
labs(title = "Average Gross of Top 10 Movies Worldwide by Year",
subtitle = "Data represents the average gross of the top 10 highest-grossing movies each year",
x = "Year",
y = "Average Gross (in million $)") +
theme_minimal()
# linear regression model
linear_model <- lm(average_gross ~ year, data = average_gross_per_year)
summary(linear_model)
par(mfrow = c(2, 2))
plot(linear_model)
# normality of residuals
shapiro.test(linear_model$residuals)
# quadratic model (polynomial model)
polynomial_model <- lm(average_gross ~ poly(year, 2), data = average_gross_per_year)
# Check the summary of the model
summary(polynomial_model)
# Plot the polynomial regression
ggplot(average_gross_per_year, aes(x = year, y = average_gross / 1e6)) +
geom_point(color = "red", size = 2) +
geom_smooth(method = "lm", formula = y ~ poly(x, 2), se = FALSE, color = "blue", size = 1) +
labs(title = "Polynomial Regression: Average Gross of Top 10 Movies Worldwide by Year",
subtitle = "Data represents the average gross of the top 10 highest-grossing movies each year",
x = "Year",
y = "Average Gross (in million $)") +
theme_minimal()
# launch ANOVA test to compare the models
anova_result <- anova(linear_model, polynomial_model)
ggplot(average_gross_per_year, aes(x = year, y = average_gross)) +
ggplot(average_gross_per_year, aes(x = year, y = average_gross / 1e6)) +
geom_line(color = "blue", size = 1) +
geom_point(color = "red", size = 2) +
labs(title = "Average Gross of Top 10 Movies Worldwide by Year",
subtitle = "Data represents the average gross of the top 10 highest-grossing movies each year",
x = "Year",
y = "Average Gross (in million $)") +
theme_minimal()
ggplot(average_gross_per_year, aes(x = year, y = average_gross / 1e6)) +
geom_line(color = "blue", size = 1) +
geom_point(color = "red", size = 2) +
labs(title = "Average Gross of Top 10 Movies Worldwide by Year",
subtitle = "Data represents the average gross of the top 10 highest-grossing movies each year",
x = "Year",
y = "Average Gross (in million $)") +
theme_minimal()
# linear regression model
linear_model <- lm(average_gross ~ year, data = average_gross_per_year)
summary(linear_model)
# Plot the polynomial regression
ggplot(average_gross_per_year, aes(x = year, y = average_gross / 1e6)) +
geom_point(color = "red", size = 2) +
geom_smooth(method = "lm", formula = y ~ poly(x, 2), se = FALSE, color = "blue", size = 1) +
labs(title = "Polynomial Regression: Average Gross of Top 10 Movies Worldwide by Year",
subtitle = "Data represents the average gross of the top 10 highest-grossing movies each year",
x = "Year",
y = "Average Gross (in million $)") +
theme_minimal()
# Plot the polynomial regression
ggplot(average_gross_per_year, aes(x = year, y = average_gross / 1e6)) +
geom_point(color = "red", size = 2) +
geom_smooth(method = "lm", formula = y ~ x, se = FALSE, color = "blue", size = 1) +
labs(title = "Polynomial Regression: Average Gross of Top 10 Movies Worldwide by Year",
subtitle = "Data represents the average gross of the top 10 highest-grossing movies each year",
x = "Year",
y = "Average Gross (in million $)") +
theme_minimal()
top10blockbusters <- read.csv("Databases/blockbuster-top_ten_movies_per_year_DFE.csv")
top10blockbusters <- read.csv("Databases/blockbuster-top_ten_movies_per_year_DFE.csv")
head(top10blockbusters)
str(top10blockbusters)
summary(top10blockbusters)
# group year and get the top 10 movies by worldwide gross for each year
top10blockbusters <- top10blockbusters %>%
group_by(year) %>%
top_n(10, worldwide_gross)
sum(is.na(top10blockbusters))
which(is.na(top10blockbusters))
top10blockbusters[397, ]
nrow(top10blockbusters)
colSums(is.na(top10blockbusters))
which(is.na(top10blockbusters$audience_freshness))
top10blockbusters$audience_freshness[397]
top10blockbusters$audience_freshness[396]
nrow(top10blockbusters)
tail(top_10_movies_per_year)
tail(top10blockbusters)
top10blockbusters <- read.csv("Databases/blockbuster-top_ten_movies_per_year_DFE.csv")
head(top10blockbusters)
str(top10blockbusters)
# alter worldwide_gross to numeric
top10blockbusters$worldwide_gross <- as.numeric(gsub("[\\$,]", "", top10blockbusters$worldwide_gross))
# group year and get the top 10 movies by worldwide gross for each year
top10blockbusters <- top10blockbusters %>%
group_by(year) %>%
top_n(10, worldwide_gross)
top10blockbusters
nrow(top10blockbusters)
sum(is.na(top10blockbusters))
# the average worldwide gross
average_gross_per_year <- top10blockbusters %>%
group_by(year) %>%
summarise(average_gross = mean(worldwide_gross))
average_gross_per_year
